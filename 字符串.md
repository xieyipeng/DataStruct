##### 顺序存储
```java
#include<stdio.h>
#include<Windows.h>
#define maxsize 100
typedef char datatype;
typedef struct {
	char str[maxsize];
	int length;
}seqstring;
void strinsert(seqstring *s,int i,seqstring T) {//  **插入子串**
	if (i<1 || i>s->length || s->length + T.length > maxsize + 1) {
		printf("can't insert!\n");
		exit(1);
	}
	else {
		for (int k = s->length-1; k > i - 1; i--) {
			//s->str[k + 1] = s->str[k];//  **插入T**
			s->str[k + T.length] = s->str[k];
		}
		for (int k = 0; k < T.length; k++) {// **写入**
			s->str[i + k - 1] = T.str[k];
		}
		s->length = s->length + T.length;
		s->str[s->length] = '\0';// **设置结束符**
	}
}
void strdelete(seqstring *S,int i,int len) {// **删除**
	if (i<1 || i>S->length || i + len - 1 > S->length) {
		printf("can't delete!\n");
		exit(1);
	}
	else {
		for (int k = i + len - 1; k < S->length; k++) {
			S->str[k - len] = S->str[k];
		}
		S->length = S->length - len;
		S->str[S->length] = '\0';
	}
}
seqstring* steconcat(seqstring S1,seqstring S2) {// **链接**
	seqstring *r;
	if (S1.length + S2.length > maxsize) {
		printf("full!\n");
		exit(1);
	}
	else {
		r = (seqstring*)malloc(sizeof(seqstring));
		for (int i = 0; i < S1.length; i++) {
			r->str[i] = S1.str[i];
		}
		for (int i = 0; i < S2.length; i++) {
			r->str[i + S1.length] = S2.str[i];
		}
		r->length = S1.length + S2.length;
		r->str[r->length] = '\0';
	}
	return r;
}
seqstring* substring(seqstring S,int i,int len) {
	seqstring *r;
	if (i<1 || i>S.length || i + len - 1 > S.length) {
		printf("error!\n");
		exit(1);
	}
	else {
		r = (seqstring*)malloc(sizeof(seqstring));
		for (int k = 0; k < len; k++) {
			r->str[k] = S.str[k + i-1];
		}
		r->length = len;
		r->str[r->length] = '\n';
	}
}
```
##### 链式存储
```java
#include<stdio.h>
#include<Windows.h>
typedef char datatype;
typedef struct node{
	char data;
	struct node *next;
}linknode;
typedef linknode *linkstring;
void strcreat(linkstring *S) {
	char ch;
	linknode *p, *r;
	*S = NULL;
	r = NULL;
	while ((ch = getchar()) != '\n') {
		p = (linknode*)malloc(sizeof(linknode));
		p->data = ch;
		if (*S == NULL) {// **S指向链表头部。r指向链表尾部
			*S = p;
		}
		else {
			r->next = p;
		}
		r = p;
	}
	if (r != NULL) {
		r->next = NULL;
	}
}
void strinsert(linkstring *S,int i,linkstring T) {
	linkstring p, q;
	p = *S;
	int k = 1;
	while (p&&k < i - 1) {
		p = p->next;
		k++;
	}
	if (!p) {
		printf("error\n");
	}
	else {
		q = T;
		while (q&&q->next) {
			q = q->next;
		}
		q->next = p->next;
		p->next = T;
	}
}
void strdelete(linkstring *s,int i,int len) {
	linkstring p, q, r;
	p = *s;
	q = NULL;
	int k = 1;
	while (p&&k < i) {// q跟踪p的前驱
		q = p;
		p = p->next;
		k++;
	}
	if (!p) {
		printf("error\n");
	}
	else {
		k = 1;
		while (k < len&&p) {
			p = p->next;
			k++;
		}
		if (!p) {
			printf("error\n");
		}
		else {
			if (!q) {
				r = *s;
				*s = p->next;
			}
			else {
				r = q->next;
				q->next = p->next;
			}
			p->next = NULL;
			while (r != NULL) {
				p = r;
				r = r->next;
				free(p);
			}
		}
	}
}
void strconcat(linkstring *S1, linkstring S2) {
	linkstring p;
	if (!(*S1)) {
		*S1 = S2;
		return;
	}
	else {
		if (S2) {
			p = *S1;
			while (p->next) {
				p = p->next;
			}
			p->next = S2;
		}
	}
}
linkstring substring(linkstring S, int i, int len) {
	linkstring p, q, r, t;
	p = S;
	int k = 1;
	while (p&&k < i) {
		p = p->next;
		k++;
	}
	if (!p) {
		printf("error\n");
		return NULL;
	}
	else {
		r = (linkstring)malloc(sizeof(linkstring));
		r->data = p->data;
		r->next = NULL;
		k = 1;
		q = r;
		while (p->next&&k < len) {
			p = p->next;
			k++;
			t = (linkstring)malloc(sizeof(linkstring));
			t->data = p->data;
			q->next = t;
			q = t;
		}
		if (k < len) {
			printf("error\n");
			return NULL;
		}
		else {
			q->next = NULL;
			return r;
		}
	}
}
```
