##### 顺序存储
```java
#include<stdio.h>
#include<Windows.h>
#define maxsize 100
typedef char datatype;
typedef struct {
	char str[maxsize];
	int length;
}seqstring;
void strinsert(seqstring *s,int i,seqstring T) {//  **插入子串**
	if (i<1 || i>s->length || s->length + T.length > maxsize + 1) {
		printf("can't insert!\n");
		exit(1);
	}
	else {
		for (int k = s->length-1; k > i - 1; i--) {
			//s->str[k + 1] = s->str[k];//  **插入T**
			s->str[k + T.length] = s->str[k];
		}
		for (int k = 0; k < T.length; k++) {// **写入**
			s->str[i + k - 1] = T.str[k];
		}
		s->length = s->length + T.length;
		s->str[s->length] = '\0';// **设置结束符**
	}
}
void strdelete(seqstring *S,int i,int len) {// **删除**
	if (i<1 || i>S->length || i + len - 1 > S->length) {
		printf("can't delete!\n");
		exit(1);
	}
	else {
		for (int k = i + len - 1; k < S->length; k++) {
			S->str[k - len] = S->str[k];
		}
		S->length = S->length - len;
		S->str[S->length] = '\0';
	}
}
seqstring* steconcat(seqstring S1,seqstring S2) {// **链接**
	seqstring *r;
	if (S1.length + S2.length > maxsize) {
		printf("full!\n");
		exit(1);
	}
	else {
		r = (seqstring*)malloc(sizeof(seqstring));
		for (int i = 0; i < S1.length; i++) {
			r->str[i] = S1.str[i];
		}
		for (int i = 0; i < S2.length; i++) {
			r->str[i + S1.length] = S2.str[i];
		}
		r->length = S1.length + S2.length;
		r->str[r->length] = '\0';
	}
	return r;
}
seqstring* substring(seqstring S,int i,int len) {
	seqstring *r;
	if (i<1 || i>S.length || i + len - 1 > S.length) {
		printf("error!\n");
		exit(1);
	}
	else {
		r = (seqstring*)malloc(sizeof(seqstring));
		for (int k = 0; k < len; k++) {
			r->str[k] = S.str[k + i-1];
		}
		r->length = len;
		r->str[r->length] = '\n';
	}
}
```
