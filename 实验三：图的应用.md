```java
#include<stdio.h>
#include<Windows.h>
#define FINITY 5000
#define M 20
#define Maxint 32767
typedef int edgetype;
typedef struct {
	char vexs[M];
	edgetype edges[M][M];
	int n, e;
}Mgraph;
int D[FINITY][FINITY], P[FINITY][FINITY];
void create(Mgraph *m,int n,int e) {
	int i, j;
	int w;//权值
	printf("please input the vertices's value:\n");
	for (int i = 1; i <= m->n; i++) {
		printf("please input %dth vertices\n",i);
		scanf("%s", &m->vexs[i]);
	}
	//for (int i = 1; i <= m->n; i++) {
	//	printf("%c",m->vexs[i]);
	//	printf("\n");
	//}
	for (i = 1; i <= m->n; i++) {//边的初始化
		for (j = 1; j <= m->n; j++) {
			m->edges[i][j] = 0;
		}	
	}
	for (int l = 1; l <= m->e; l++) {//给边赋权值
		printf("hello\n");
		printf("please input the %dth 'i' and 'j' and value\n",l);
		scanf("%d%d%d", &i, &j, &w);
		m->edges[i][j] = w;
		m->edges[j][i] = w;
	}
	printf("create over!\n");
}
void Djkstra(Mgraph *m,int v1,int n) {
	int D2[FINITY], P2[FINITY],v;
	boolean S[FINITY];
	for (int i = 1; i <= n; i++) {
		S[i] = false;
		D2[i] = m->edges[v1][i];
		if (D2[i] < Maxint) {
			P2[i] = v1;
		}
		else {
			P2[i] = 0;
		}
	}
	P2[v1] = 0;
	S[v1] = true;
	for (int i = 2; i < n; i++) {
		int min = Maxint;
		for (int i = 1; i <= n; i++) {
			if (!S[i] && D2[i] < min) {
				v = i;
				min = D2[i];
			}
		}
		S[v] = true;
		for (int i = 1; i <= n; i++) {
			if (!S[i] && D2[v] + m->edges[v][i] < D2[i]) {
				D2[i] = D2[v] + m->edges[v][i];
				P2[i] = v;
			}
		}
		printf("the shortest rood:\n");
		for (int i = 0; i <= n; i++) {
			printf("%d", D2[i]);
			printf("%d", i);
			while (v != 0) {
				printf("<-%d", D2[i]);
				v = P2[v];
			}
			printf("\n");
		}
	}
}
void Floyd(Mgraph *m,int n) {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; i <= n; i++) {
			if (m->edges[i][j] != Maxint) {
				m->edges[i][j] = j;
			}
			else {
				m->edges[i][j] = 0;
				D[i][j] = m->edges[i][j];
			}
		}
	}
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (D[i][k] + D[k][j] < D[i][j]) {
					D[i][j] = D[i][k] + D[k][j];
					P[i][j] = P[i][k];
					printf("D i j = %d , P i j = %d", D[i][j], P[i][j]);
				}
			}
		}
	}
	printf("please input the start and the end\n");
	int s, e;
	scanf("%d%d", &s, &e);
	if (P[s][e] == 0) {
		printf("null\n");
	}
	else {
		printf("the shortest rood is:\n");
		while (P[s][e] != e) {
			printf("->%d", P[s][e]);
			P[s][e] = P[P[s][e]][e];
		}
		printf("->%d", e);
		printf("the shortest rood is%d\n", D[s][e]);
	}
}
int main() {
	Mgraph *mgraph;
	mgraph = (Mgraph*)malloc(sizeof(Mgraph));
	printf("please input the vertices'n' and the edge 'e':\n");
	scanf("%d%d", &mgraph->n, &mgraph->e);
	create(mgraph, mgraph->n,mgraph->e);
	int v;
	printf("please input whitch city you want to find\n");
	scanf("%d", &v);
	printf("Djkstra\n");
	Djkstra(mgraph, v, mgraph->n);
	printf("Floyd\n");
	Floyd(mgraph, mgraph->n);
	system("pause");
	return 0;
}
```
