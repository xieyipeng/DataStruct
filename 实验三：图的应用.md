```java
#include<stdio.h>
#include<Windows.h>
#define FINITY 5000
#define M 20
#define Maxint 32767
typedef char vertextype;
typedef int edgetype;
typedef struct {
	vertextype vexs[M];
	edgetype edges[M][M];
	int n, e;
}Mgraph;
int D[FINITY][FINITY], P[FINITY][FINITY];
void create(Mgraph *m,int n,int e) {
	int i, j;
	int w;//权值
	printf("please input the vertices's value:\n");
	for (int i = 1; i <= m->n; i++) {//顶点
		printf("please input %dth vertices\n",i);
		scanf("%s", m->vexs[i]);
	}
	for (i = 1; i <= m->n; i++) {
		printf("%d",m->vexs[i]);
		printf("\n");
	}
	for (i = 1; i <= m->n; i++) {//边的初始化
		for (j = 0; j < m->n; j++) {
			m->edges[i][j] = 0;
		}	
	}
	for (int i = 1; i <= m->e; i++) {//给边赋权值
		printf("please input the %dth 'i' and 'j' and value\n",i+1);
		scanf("%d%d%d", &i, &j, &w);
		m->edges[i][j] = w;
	}
	printf("create over!\n");
}
void Djkstra(Mgraph *m,int v1,int n) {
	int D2[FINITY], P2[FINITY],v;
	boolean S[FINITY];
	for (int i = 1; i <= n; i++) {
		S[i] = false;
		D2[i] = m->edges[v1][i];
		if (D2[i] < Maxint) {
			P2[i] = v1;
		}
		else {
			P2[i] = 0;
		}
	}
	P2[v1] = 0;
	S[v1] = true;
	for (int i = 2; i < n; i++) {
		int min = Maxint;
		for (int i = 1; i <= n; i++) {
			if (!S[i] && D2[i] < min) {
				v = i;
				min = D2[i];
			}
		}
		S[v] = true;
		for (int i = 1; i <= n; i++) {
			if (!S[i] && D2[v] + m->edges[v][i] < D2[i]) {
				D2[i] = D2[v] + m->edges[v][i];
				P2[i] = v;
			}
		}
		printf("the shortest rood:\n");
		for (int i = 0; i <= n; i++) {
			printf("%d", D2[i]);
			printf("%d", i);
			while (v != 0) {
				printf("<-%d", D2[i]);
				v = P2[v];
			}
			printf("\n");
		}
	}
}
void Floyd(Mgraph *m,int n) {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; i <= n; i++) {
			if (m->edges[i][j] != Maxint) {
				m->edges[i][j] = j;
			}
			else {
				m->edges[i][j] = 0;
				D[i][j] = m->edges[i][j];
			}
		}
	}
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (D[i][k] + D[k][j] < D[i][j]) {
					D[i][j] = D[i][k] + D[k][j];
					P[i][j] = P[i][k];
					printf("D i j = %d , P i j = %d", D[i][j], P[i][j]);
				}
			}
		}
	}
}
int main() {
	Mgraph *mgraph;
	mgraph = (Mgraph*)malloc(sizeof(Mgraph));
	printf("please input the vertices'n' and the edge 'e':\n");
	scanf("%d%d", &mgraph->n, &mgraph->e);
	create(mgraph, mgraph->n,mgraph->e);
	int v;
	printf("please input whitch city you want to find\n");
	scanf("%d", v);
	printf("Djkstra\n");
	Djkstra(mgraph, v, mgraph->n);
	printf("Floyd\n");
	Floyd(mgraph, mgraph->n);
	system("pause");
	return 0;
}
```
