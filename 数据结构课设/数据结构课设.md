```java
#define _CRT_SECURE_NO_DEPRECATE
#include<stdio.h>
#include <tchar.h>
#include<Windows.h>
#define FINITY 5000
#define M 80
#define TRUE 1
#define REACHABLE 1
#define FALSE 0
typedef int vertextype;
typedef float edgetype;
typedef struct {
	vertextype vexs[M];
	edgetype edges[M][M];
	int n, e;
}Mgraph;
typedef struct {
	int nodes[M];
	int size;
}Path;
typedef struct {
	int num[M];
	int vex[M];
	char name[M][M];
	char info[M][M];
	int size;
}View;
void Creat(Mgraph *g) {
	int i, j, k;
	FILE *rf, *vs;
	rf = fopen("F:\\VS-community\\graph.txt", "r");
	vs = fopen("F:\\VS-community\\vexs.txt", "r");
	if (vs && rf) {
		for (i = 1; i <= g->n; i++) {
			fscanf(vs, "%d", &g->vexs[i]);
		}
		for (i = 1; i <= g->n; i++) {
			for (j = 1; j <= g->n; j++) {
				if (i == j) {
					g->edges[i][j] = 0;
				}
				else {
					g->edges[i][j] = FINITY;
				}
			}
		}
		for (k = 0; k < g->e; k++) {
			char w[M];
			float f;
			fscanf(rf, "%d %d %s", &i, &j, &w);
			f = atof(w);
			g->edges[i][j] = f;
			g->edges[j][i] = f;
		}
		fclose(vs);
		fclose(rf);
	}
	else {
		printf("error: 无法打开文件！！\n");
	}
}
int visited[M];
int besure[M][M];
int isused[M][M];
void DFS(Mgraph *g, int i) {
	int j;
	visited[i] = 1;
	printf("%d->", g->vexs[i]);
	for (j = 1; j <= g->n; j++) {
		//if (i == j) {
		//	printf("i==j,%f\n", g->edges[i][j]);
		//	printf("visited[j]:%d\n", visited[j]);
		//}
		if (g->edges[i][j] != FINITY && visited[j] == 0) {
			DFS(g, j);
		}
	}
}
void DFSTraverse(Mgraph *g) {
	for (int i = 1; i <= g->n; i++) {
		visited[i] = 0;
	}
	for (int i = 1; i <= g->n; i++) {
		for (int j = 1; j <= g->n; j++) {
			besure[i][j] = 0;
		}
	}
	for (int i = 1; i <= g->n; i++) {
		for (int j = 1; j <= g->n; j++) {
			if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
				besure[i][j] = 1;
			}
			else {
				besure[i][j] = 0;
			}
		}
	}
	for (int i = 1; i <= g->n; i++) {
		if (visited[i] == 0) {
			DFS(g, i);
		}
	}
}
void dfs(Mgraph *g) {
	int start, end;
	int pathNum = 0;
	Path path;
	path.size = 0;
	printf("请输入起始标号和终止标号\n");
	scanf("%d%d", &start, &end);
	path.nodes[path.size] = start;
	path.size++;
	for (int i = 1; i <= g->n; i++) {
		visited[i] = 0;
	}
	for (int i = 1; i <= g->n; i++) {
		for (int j = 1; j <= g->n; j++) {
			besure[i][j] = 0;
		}
	}
	for (int i = 1; i <= g->n; i++) {
		for (int j = 1; j <= g->n; j++) {
			if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
				besure[i][j] = 1;
			}
			else {
				besure[i][j] = 0;
			}
		}
	}
	for (int i = 1; i <= g->n; i++) {
		for (int j = 1; j <= g->n; j++) {
			isused[i][j] = 0;
		}
	}
	visited[start] = 1;
	while (path.size != 0) {
		int flag = path.nodes[path.size-1];
		int time = 0;
		for (int i = 1; i <= g->n; i++) {
			if (visited[i] == 0 && besure[flag][i] == 1 && isused[flag][i] == 0) {
				visited[i] = 1;
				isused[flag][i] = 1;
				isused[i][flag] = 1;
				path.nodes[path.size] = i;
				path.size++;
				time++;
			}
			if (path.nodes[path.size - 1] == end) {
				printf("end\n");
				visited[end] = 0;
				Path temp;
				temp = path;
					while (temp.size > 1) {
					printf("%d<-", temp.nodes[temp.size - 1]);
					temp.size--;
				}
			printf("%d\n", temp.nodes[0]);
			path.size--;
			}
		}
		if (time == 0) {
			path.size--;
			for (int i = 0; i <= g->n; i++) {
				isused[flag][i] = 0;
			}
			continue;
		}
	}
}
//getPath( )注释
//int time = 1;
/*
void getpaths(int map[M][M], int n, int start, int end, int isNodeUsed[], Path paths[], int *pathsNum) {
	printf("\n第%d次调用getPath函数！！\n", time);
	int i, j;
	printf("重新定义temp数组,start是%d,end是%d\n", start, end);
	Path tempPaths[M];
	for (i = 0; i < M; i++) {
		tempPaths[i].size = 0;
	}
	int tempPathsNum;
	printf("令isNodeUsed[%d]==true,标记为已用\n", start);
	isNodeUsed[start] = TRUE;
	printf("函数中的第一个for循环：\n");
	for (i = 1; i <= n; i++) {
		if (isNodeUsed[i] == FALSE&&map[start][i] == REACHABLE) {//两点相邻并可达
			printf("start:%d点 和 i:%d点相邻并可达\n", start, i);
			if (i == end) {
				printf("i==end\n");
				paths[(*pathsNum)].size = 2;
				paths[(*pathsNum)].nodes[0] = end;
				paths[(*pathsNum)].nodes[1] = start;
				printf("(*pathsNum) %d 的node[0] 加end,%d\n", *pathsNum, end);
				printf("(*pathsNum) %d 的node[1] 加start,%d\n", *pathsNum, start);
				(*pathsNum)++;
				printf("*pathsNum:%d\n", *pathsNum);
			}
			else {
				printf("else,令tempPathNum置零\n");
				tempPathsNum = 0;
				printf("重新调用getpath函数\n");
				printf("\n");
				getpaths(map, n, i, end, isNodeUsed, tempPaths, &tempPathsNum);
				printf("调用getpath函数后，tempPathNum是：%d\n", tempPathsNum);
				for (j = 0; j<tempPathsNum; j++) {
					printf("hello for:\n");
					tempPaths[j].nodes[tempPaths[j].size] = start;
					printf("给tempPaths[%d]加node[%d]=%d\n", j, tempPaths[j].size, start);
					tempPaths[j].size++;
					printf("tempPaths[%d].size++,tempPaths[%d]=%d\n", j, j, tempPaths[j].size);
					paths[(*pathsNum)] = tempPaths[j];
					printf("交换\n");
					(*pathsNum)++;
					printf("pathNum++,=%d\n", *pathsNum);
				}
			}
		}
	}
	isNodeUsed[start] = FALSE;
	printf("令isNodeUsed[%d]==false,修改为未用。。\n", start);
	printf("\n");
	time++;
}
*/
void getpaths(int map[M][M], int n, int start, int end, int isNodeUsed[], Path paths[], int *pathsNum) {
	int i, j;
	Path tempPaths[M];
	for (i = 0; i < M; i++) {
		tempPaths[i].size = 0;
	}
	int tempPathsNum;
	isNodeUsed[start] = TRUE;
	for (i = 1; i <= n; i++) {
		if (isNodeUsed[i] == FALSE&&map[start][i] == REACHABLE) {//两点相邻并可达
			if (i == end) {
				paths[(*pathsNum)].size = 2;
				paths[(*pathsNum)].nodes[0] = end;
				paths[(*pathsNum)].nodes[1] = start;
				(*pathsNum)++;
			}
			else {
				tempPathsNum = 0;
				getpaths(map, n, i, end, isNodeUsed, tempPaths, &tempPathsNum);
				for (j = 0; j<tempPathsNum; j++) {
					tempPaths[j].nodes[tempPaths[j].size] = start;
					tempPaths[j].size++;
					paths[(*pathsNum)] = tempPaths[j];
					(*pathsNum)++;
				}
			}
		}
	}
	isNodeUsed[start] = FALSE;
}
void fuzhu(Mgraph *g) {
	int map[M][M];
	int isNodeUsed[M];
	Path paths[M];
	for (int l = 0; l < M;  l++) {
		paths[l].size = 0;
	}
	int i, j;
	for (i = 1; i <= g->n; i++) {
		isNodeUsed[i] = FALSE;
		for (j = 1; j <= g->n; j++) {
			map[i][j] = FINITY;
		}
	}
	for (i = 1; i <= g->n; i++) {
		for (j = 1; j <= g->n; j++) {
			if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
				map[i][j] = 1;
			}
			else {
				map[i][j] = 0;
			}
		}
	}
	int start, end, pathNum;
	pathNum = 0;
	printf("输入要寻找的两个节点\n");
	scanf("%d%d", &start, &end);
	getpaths(map, g->n, start, end, isNodeUsed, paths, &pathNum);
	printf("寻找完成!共有%d条路径！\n", pathNum);
	for (i = 0; i<pathNum; i++) {
		printf("第%d条路径为：\n", i + 1);
		for (j = paths[i].size - 1; j >= 1; j--) {
			printf("%d -> ", paths[i].nodes[j]);
		}
		printf("%d\n", paths[i].nodes[j]);
	}
}
typedef enum { False, True }boo;
typedef float dist[M];
typedef int path[M];
void spath_dij(Mgraph *g, int v0, path p, dist d){
	boolean final[M];
	int i, k, v;
	float min;
	for (v = 1; v <= g->n; v++){
		final[v] = False;
		d[v] = g->edges[v0][v];
		if (d[v]< FINITY &&d[v] != 0)
			p[v] = v0;
		else
			p[v] = -1;
	}
	final[v0] = True; d[v0] = 0;
	for (i = 1; i < g->n; i++){
		min = FINITY;
		for (k = 1; k <= g->n; ++k){
			if (!final[k] && d[k] < min){
				v = k;
				min = d[k];
			}
		}
		if (min == FINITY) {
			return;
		}
		else {
			final[v] = True;
		}
		for (k = 1; k <= g->n; ++k)
			if (!final[k] && (min + g->edges[v][k] < d[k])){
				d[k] = min + g->edges[v][k];
				p[k] = v;
			}
	}
}
void print_gpd(Mgraph *g, path p, dist d, int vn){
	int end = vn;
	int st[M];
	printf("到达目的地的最短距离为：%f\n", d[end]);
	int i;
	for (i = 0; p[end] != -1; i++){
		st[i] = p[end];
		end = p[end];
	}
	printf("到达该地的最短路径为:");
	for (int j = i-1; j >= 0; j--){
		printf("%d->", st[j]);
	}
	printf("%d\n", vn);
}
void choice() {
	printf("*****************************************************\n");
	printf("*     请按照序号输入您想使用的功能,退出请输入-1     *\n");
	printf("*****************************************************\n");
	printf("*         1--查询某个景点的信息                     *\n");
	printf("*         2--查询任意两个景点之间的最短路径         *\n");
	printf("*         3--查询任意两个景点间的所有路径           *\n");
	printf("*         4--查询多个景点的最佳访问路线             *\n");
	printf("*         5--对地图进行深度优先遍历                 *\n");
	printf("*         6--查询任意两个景点间的所有路径,自己的    *\n");
	printf("*****************************************************\n");
}
void CreatView(View* v) {
	FILE *info;
	char cc;
	int i;
	v->size = 10;
	info = fopen("F:\\VS-community\\View.txt", "r");
	for (i = 0; i < v->size; i++){
		fscanf(info, "%d%d%s%s", &(v->num[i]), &(v->vex[i]), v->name[i], v->info[i]);
	}
	fclose(info);
}
void find(View* view, int nu) {
	if (nu <= 0 || nu > 10) {
		printf("请输入正确的景点编号！\n");
	}
	else {
		printf("%d  %s  %s\n", view->num[nu - 1], view->name[nu - 1], view->info[nu - 1]);
	}
}
int main() {
	Mgraph *mg;
	Path *p;
	View* v;
	v = (View*)malloc(sizeof(View));
	p = (Path*)malloc(sizeof(Path));
	mg = (Mgraph*)malloc(sizeof(Mgraph));
	mg->n = 49;
	mg->e = 53;
	Creat(mg);
	printf("*****************************************************\n");
	printf("*                   地图创建成功！                  *\n");
	CreatView(v);
	printf("*****************************************************\n");
	printf("*                 地图信息创建成功！                *\n");
	int use = 0;
	while (use != -1) {
		choice();
		scanf("%d", &use);
		switch (use) {
		case 1:
			int i;
			printf("请输入查询景点编号：\n");
			scanf("%d", &i);
			find(v, i);
			break;
		case 2:
			int v0;
			int vn;
			path p1;
			dist d;
			Creat(mg);
			printf("请输入起始点标号以及目的地的标号：");
			scanf("%d%d", &v0, &vn);
			spath_dij(mg, v0, p1, d);
			printf("该点到目的地的最短路径为:\n");
			print_gpd(mg, p1, d, vn);
			break;
		case 3:
			fuzhu(mg);
			break;
		case 4:
			break;
		case 5:
			printf("DFS深度遍历序列：\n");
			DFSTraverse(mg);
			printf("\n");
			break;
		case 6:
			dfs(mg);
			break;
		default:
			break;
		}
		system("pause");
		system("cls");
	}
	system("pause");
	return 0;
}
/*
1 --大门
2 --徳怀广场
3 --左大门
4 --右大门
5 --山西超重力化工研究中心
6 --德怀楼
7 --酬学楼
8 --校史馆
9 --2号教学楼
10--勤学楼
11--明学楼
12--颐学楼
13--一号足球场
14--怡丁院
15--二道门
16--三道门
17--四道门
18--五道门
19--柏林园
20--二龙山
21--一号中央大道
22--科艺苑
23--文瀛一号宿舍区
24--学生一食堂
25--快递区
26--文瀛二号宿舍区
27--鸿学楼
28--田径运动场
29--网球场
30--体育馆
31--一号篮球场
32--图书馆
33--行知广场
34--教学主楼
35--测试技术实验室
36--惠学楼
37--实验楼
38--山西精密成型工程中心
39--二号篮球场
40--致学广场
41--致学楼
42--敏学楼
43--教工宿舍
44--附中附小
45--校医院
46--中老年活动中心
47--游泳馆
48--国防重点学科实验室
49--二号足球场
*/
```
