```java
#include<stdio.h>
#include<Windows.h>
#include<math.h>
#define FINITY 5000
#define M 2500
#define TRUE 1
#define REACHABLE 1
#define FALSE 0
typedef int vertextype;
typedef float edgetype;
typedef struct {
	vertextype vexs[M];
	edgetype edges[M][M];
	int n, e;
}Mgraph;
typedef struct {
	int nodes[M];
	int size;
}Path;
void Creat(Mgraph *g) {//  **构建无向图**
	int i, j, k;
	FILE *rf, *vs;
	rf = fopen("F:\\VS-community\\graph1.txt", "r");
	vs = fopen("F:\\VS-community\\vexs.txt", "r");
	if (vs && rf) {
		for (i = 1; i <= g->n; i++) {
			fscanf(vs, "%d", &g->vexs[i]);
		}
		for (i = 1; i <= g->n; i++) {
			for (j = 1; j <= g->n; j++) {
				if (i == j) {
					g->edges[i][j] = 0;
				}
				else {
					g->edges[i][j] = FINITY;
				}
			}
		}
		for (k = 0; k < g->e; k++) {
			char w[M];
			float f;
			fscanf(rf, "%d %d %s", &i, &j, &w);
			f = atof(w);
			g->edges[i][j] = f;
			g->edges[j][i] = f;
		}
		fclose(vs);
		fclose(rf);
		printf("地图创建成功！\n");
	}
	else {
		printf("error: 无法打开文件！！\n");
	}
}
int visited[M];
int besure[M][M];
/*
int isEmpty(Path p) {
if (p.top == 0) {
return 1;
}
else {
return 0;
}
}
void PrintAllPath(Mgraph *g) {
int start, end;
printf("输入起始地点标号：\n");
scanf("%d", &start);
printf("输入终止地点标号：\n");
scanf("%d", &end);
for (int i = 1; i <= g->n; i++) {
for (int j = 1; j <= g->n; j++) {
besure[i][j] = 0;
}
}
for (int i = 1; i <= g->n; i++) {
for (int j = 1; j <= g->n; j++) {
if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
besure[i][j] = 1;
}
else {
besure[i][j] = 0;
}
}
}
if (start<1 || end<1 || start>g->n || end>g->n) {
printf("请输入正确的序号！");
return;
}
bool *isvisited = (bool*)malloc(sizeof(bool) * g->n);
for (int i = 1; i <= g->n; i++) {
isvisited[i] = false;
}
Path *Gnode;
Gnode = (Path*)malloc(sizeof(Path));
Gnode->top = 0;
Gnode->path[Gnode->top] = g->vexs[start];
Gnode->top++;
isvisited[start] = true;
int top_node;
int pop_node = 0;
while (!isEmpty(*Gnode)) {
top_node = Gnode->path[Gnode->top-1];
int k;
for (k = pop_node + 1; k <= g->n; k++) {
if (besure[top_node][k] == 1 && isvisited[k] == false) {
if (g->vexs[k] == end) {
Gnode->path[Gnode->top] = g->vexs[k];
Gnode->top++;
while (Gnode->top>0) {
printf("<-%d", Gnode->path[Gnode->top-1]);
Gnode->top--;
}
printf("\n");
pop_node= Gnode->path[Gnode->top-1];
break;
}
else {
pop_node = -1;
isvisited[k] = true;
Gnode->path[Gnode->top] = g->vexs[k];
Gnode->top++;
break;
}
}
}
if (k == g->n+1) {
pop_node= Gnode->path[Gnode->top-1];
for (int c = 1; c <= g->n; c++) {
if (besure[pop_node][c] == 1 && (c != start)) {
isvisited[c] = false;
}
}
Gnode->top--;
}
}
}
*/
//void DFS(Mgraph *g, int i) {
//	int j;
//	visited[i] = 1;
//	printf("%d->", g->vexs[i]);
//	for (j = 1; j <= g->n; j++) {
//		if (g->edges[i][j] != FINITY && visited[j] == 0) {
//			DFS(g, j);
//		}
//	}
//}
//void DFSTraverse(Mgraph *g) {
//	for (int i = 1; i <= g->n; i++) {
//		visited[i] = 0;
//	}
//	for (int i = 1; i <= g->n; i++) {
//		for (int j = 1; j <= g->n; j++) {
//			besure[i][j] = 0;
//		}
//	}
//	for (int i = 1; i <= g->n; i++) {
//		for (int j = 1; j <= g->n; j++) {
//			if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
//				besure[i][j] = 1;
//			}
//			else {
//				besure[i][j] = 0;
//			}
//		}
//	}
//	for (int i = 1; i <= g->n; i++) {
//		if (visited[i] == 0) {
//			DFS(g, i);
//		}
//	}
//}
void getpaths(int map[M][M], int n, int start, int end, int isNodeUsed[], Path paths[], int *pathsNum) {
	printf("getpaths\n");
	int i, j;
	Path tempPaths[M];
	int tempPathsNum;
	isNodeUsed[start] = TRUE;
	for (i = 1; i <= n; i++) {
		if (isNodeUsed[i] == FALSE&&map[start][i] == REACHABLE) {
			if (i == end) {
				paths[(*pathsNum)].size = 2;
				paths[(*pathsNum)].nodes[0] = end;
				paths[(*pathsNum)].nodes[1] = start;
				(*pathsNum)++;
			}
			else {
				tempPathsNum = 0;
				getpaths(map, n, i, end, isNodeUsed, tempPaths, &tempPathsNum);
				for (j = 0; j<tempPathsNum; j++) {
					tempPaths[j].nodes[tempPaths[j].size] = start;
					tempPaths[j].size++;
					paths[(*pathsNum)] = tempPaths[j];
					(*pathsNum)++;
				}
			}
		}
	}
	isNodeUsed[start] = FALSE;
}
void fuzhu(Mgraph *g) {
	int map[M][M];
	int isNodeUsed[M];
	Path paths[M];
	for (int l = 0; l < M;  l++) {
		paths[l].size = 0;
	}
	int i, j;
	for (i = 1; i <= g->n; i++) {
		isNodeUsed[i] = FALSE;
		for (j = 1; j <= g->n; j++) {
			map[i][j] = FINITY;
		}
	}
	for (i = 1; i <= g->n; i++) {
		for (j = 1; j <= g->n; j++) {
			if (g->edges[i][j] != FINITY&&g->edges[i][j] != 0) {
				map[i][j] = 1;
			}
			else {
				map[i][j] = 0;
			}
		}
	}
	int start, end, pathNum;
	pathNum = 0;
	printf("输入要寻找的两个节点\n");
	scanf("%d%d", &start, &end);
	getpaths(map, g->n, start, end, isNodeUsed, paths, &pathNum);
	for (i = 0; i<pathNum; i++) {
		for (j = paths[i].size - 1; j >= 1; j--) {
			printf("%d -> ", paths[i].nodes[j]);
		}
		printf("%d\n", paths[i].nodes[j]);
	}
}
int main() {
	Mgraph *mg;
	Path *p;
	p = (Path*)malloc(sizeof(Path));
	mg = (Mgraph*)malloc(sizeof(Mgraph));
	mg->n = 49;
	mg->e = 66;
	Creat(mg);
	/*
	printf("寻找所有路径：\n");
	printf("DFS深度遍历序列：\n");
	DFSTraverse(mg);
	*/
	printf("寻找任意两点间的所有路径：\n");
	fuzhu(mg);
	system("pause");
	return 0;
}
/*
1 --大门
2 --徳怀广场
3 --左大门
4 --右大门
5 --山西超重力化工研究中心
6 --德怀楼
7 --酬学楼
8 --校史馆
9 --2号教学楼
10--勤学楼
11--明学楼
12--颐学楼
13--一号足球场
14--怡丁院
15--二道门
16--三道门
17--四道门
18--五道门
19--柏林园
20--二龙山
21--一号中央大道
22--科艺苑
23--文瀛一号宿舍区
24--学生一食堂
25--快递区
26--文瀛二号宿舍区
27--鸿学楼
28--田径运动场
29--网球场
30--体育馆
31--一号篮球场
32--图书馆
33--行知广场
34--教学主楼
35--测试技术实验室
36--惠学楼
37--实验楼
38--山西精密成型工程中心
39--二号篮球场
40--致学广场
41--致学楼
42--敏学楼
43--教工宿舍
44--附中附小
45--校医院
46--中老年活动中心
47--游泳馆
48--国防重点学科实验室
49--二号足球场
*/
```
